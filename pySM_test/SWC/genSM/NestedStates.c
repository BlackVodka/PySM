/******************************************************************************
 *                                                                            *
 * Generated by pySM - The python state machine code generator                *
 *                                                                            *
 *****************************************************************************/

/**
 * @file SimpleEx.c
 * @author Markus Burger
 * @date 2017-11-04
 * @brief Header for generated state machine simpleEx
 * Generated 2017-11-04 13:36:42 by PySM - The python state machine generator.
 */
 

/* ========================================================================= */
/* INCLUDES                                                                  */
/* ========================================================================= */
#include "NestedStates.h"


#define DEACTIVATE_STATE(statename)	do{\
	nestedStates_stateStati[statename] = NESTEDSTATES_STATE_INACTIVE;\
}while(0)
#define ACTIVATE_STATE(statename)	do{\
	nestedStates_activeState = statename;\
	nestedStates_stateStati[statename] = NESTEDSTATES_STATE_ACTIVE;\
}while(0)


/* ========================================================================= */
/* STATE FUNCTION (SF) PROTOTYPES                                            */
/* ========================================================================= */
static void nestedStates_SF_SUP_A_entry(void);
static void nestedStates_SF_SUP_B_entry(void);
static void nestedStates_SF_SUP_C_entry(void);
static void nestedStates_SF_SUP_D_entry(void);
static void nestedStates_SF_SUB_A(void);
static void nestedStates_SF_SUB_B(void);
static void nestedStates_SF_SUB_C(void);
static void nestedStates_SF_SUB_D(void);
static void nestedStates_SF_SUB_E(void);
static void nestedStates_SF_SUB_F(void);


/* ========================================================================= */
/* STATE MACHINE VARIABLE RESET FUNCTION                                     */
/* ========================================================================= */
static void nestedStates_variableResetFunction(void);


/* ========================================================================= */
/* STATE TRANSITION TEST FUNCTION (TTF) PROTOTYPES                           */
/* ========================================================================= */
static pySm_bool nestedStates_TTF_SUP_A_to_SUP_C(void);
static pySm_bool nestedStates_TTF_SUB_A_to_SUP_C(void);
static pySm_bool nestedStates_TTF_SUB_A_to_SUB_D(void);
static pySm_bool nestedStates_TTF_SUP_A_to_SUB_E(void);
static pySm_bool nestedStates_TTF_SUB_B_to_SUB_C(void);
static pySm_bool nestedStates_TTF_SUB_A_to_SUB_C(void);
static pySm_bool nestedStates_TTF_SUP_B_to_SUB_D(void);
static pySm_bool nestedStates_TTF_SUB_B_to_SUB_D(void);
static pySm_bool nestedStates_TTF_SUB_C_to_SUB_F(void);


/* ========================================================================= */
/*  TODO TEXT: PROTOTYPES                                                    */
/* ========================================================================= */
pySm_returnType nestedStates_runModel(void);
pySm_returnType nestedStates_runSubSM_SUP_A(nestedStates_exitRequestType);
pySm_returnType nestedStates_runSubSM_SUP_B(nestedStates_exitRequestType);



/* ========================================================================= */
/* DE- AND INITALIZATION OF MODULE LOCAL (STATIC) VARIABLES                  */
/* ========================================================================= */
static nestedStates_inputSignalsType* nestedStates_inputSignals;
static nestedStates_outputSignalsType* nestedStates_outputSignals;
static nestedStates_activeStateType nestedStates_activeState = NESTEDSTATES_RESERVED_INVALID_STATE;

static nestedStates_activeStateType nestedStates_rootActiveState = NESTEDSTATES_SUP_A;
static nestedStates_activeStateType nestedStates_subSM_SUP_A = NESTEDSTATES_SUP_B;
static nestedStates_activeStateType nestedStates_subSM_SUP_B = NESTEDSTATES_SUB_A;

nestedStates_stateStatusType nestedStates_stateStati[NESTEDSTATES_TOTAL_NUMBER_OF_STATES];

static pySm_uint16 localVar = 0u;


/* ========================================================================= */
/* IMPLEMENTATION : STATE MACHINE VARIABLE RESET FUNCTION                    */
/* ========================================================================= */
static void nestedStates_variableResetFunction(void)
{
	localVar = 0u;
}


/* ========================================================================= */
/* IMPLEMENTATION : STATE FUNCTIONS                                          */
/* ========================================================================= */
static void nestedStates_SF_SUP_A_entry(void)
{
	localVar = 0u;
}

static void nestedStates_SF_SUP_B_entry(void)
{
	localVar = 0u;
}

static void nestedStates_SF_SUP_C_entry(void)
{
	localVar = 0u;
}

static void nestedStates_SF_SUP_D_entry(void)
{
	localVar = 0u;
}

static void nestedStates_SF_SUP_E_entry(void)
{
	localVar = 0u;
}

static void nestedStates_SF_SUP_F_entry(void)
{
	localVar = 0u;
}

static void nestedStates_SF_SUP_G_entry(void)
{
	localVar = 0u;
}



static void nestedStates_SF_SUB_A(void)
{
	localVar++;
}

static void nestedStates_SF_SUB_B(void)
{
	localVar++;
}

static void nestedStates_SF_SUB_C(void)
{
	localVar++;
}

static void nestedStates_SF_SUB_D(void)
{
	localVar++;
}

static void nestedStates_SF_SUB_E(void)
{
	localVar++;
}

static void nestedStates_SF_SUB_F(void)
{
	localVar++;
}


/* ========================================================================= */
/* IMPLEMENTATION : TRANSITION TEST FUNCTIONS (TTFs)                         */
/* ========================================================================= */
static pySm_bool nestedStates_TTF_SUP_A_to_SUP_C(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_a
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_A_to_SUP_C(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_b
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_A_to_SUB_D(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_c
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_A_to_SUB_B(void)
{
	pySm_bool rtrn = (
		 PYSM_TRUE
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUP_A_to_SUB_E(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_d
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_B_to_SUB_C(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_e
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_A_to_SUB_C(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_f
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUP_B_to_SUB_D(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_g
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_B_to_SUB_D(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_h
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_C_to_SUB_F(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_i
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUP_A_to_SUP_E(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_j
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUP_F_to_SUP_G(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_k
		);
	return rtrn;
}

static pySm_bool nestedStates_TTF_SUB_J_to_SUP_D(void)
{
	pySm_bool rtrn = (
		 nestedStates_inputSignals->trigger_l
		);
	return rtrn;
}


/* ========================================================================= */
/* IMPLEMENTATION : API FUNCTIONS                                            */
/* ========================================================================= */
pySm_returnType NestedStates_init(void)
{
	nestedStates_stateStatusType stateStatusIdx;

	nestedStates_activeState = NESTEDSTATES_SUP_A;
	nestedStates_rootActiveState = NESTEDSTATES_SUP_A;
	nestedStates_subSM_SUP_A = NESTEDSTATES_SUP_B;
	nestedStates_subSM_SUP_B = NESTEDSTATES_SUB_A;

	for(stateStatusIdx = 0u; stateStatusIdx < NESTEDSTATES_TOTAL_NUMBER_OF_STATES; stateStatusIdx)
	{
		nestedStates_stateStati[stateStatusIdx] = NESTEDSTATES_STATE_INACTIVE;
	}

	return PYSM_E_OK;
}


pySm_returnType NestedStates_mainFunction(nestedStates_inputSignalsType* swc_inputSignals,
		nestedStates_outputSignalsType* swc_outputSignals)
{
	pySm_returnType runStateMachineResult;

	nestedStates_inputSignals = swc_inputSignals;
	nestedStates_outputSignals = swc_outputSignals;

	/* Run state machine on model root level */
	(void)nestedStates_runModel();

	return runStateMachineResult;
}


void NestedStates_getActiveState(nestedStates_activeStateType* swc_activeState)
{
	*swc_activeState = nestedStates_activeState;
}

pySm_returnType nestedStates_runModel(void)
{
	switch(nestedStates_rootActiveState)
	{
		case NESTEDSTATES_SUP_A:
			/* --- Handle entry --- */
			if(NESTEDSTATES_STATE_ACTIVE != nestedStates_stateStati[NESTEDSTATES_SUP_A])
			{
				ACTIVATE_STATE(NESTEDSTATES_SUP_A);
				nestedStates_SF_SUP_A_entry();
				/* Run sub-statemachines, if any for entering substates */
				(void)nestedStates_runSubSM_SUP_A(NESTEDSTATES_NO_EXIT_REQUESTED);
			}
			/* --- Handle exiting transitions and during() executions --- */
			else
			{
				if(nestedStates_TTF_SUP_A_to_SUP_C())
				{
					/* --- Execute TAF, if any --- */
					/* Transition SUP_A_to_SUP_C has no TAF */
					/* --- Run exit() of substates, if any --- */
					(void)nestedStates_runSubSM_SUP_A(NESTEDSTATES_EXIT_REQUESTED);
					/* --- Run exit() of active state on current level , if any --- */
					/* SUP_A has no exit() */
					/* --- Reset current superstate to default state --- */
					nestedStates_rootActiveState = NESTEDSTATES_SUP_A;
					DEACTIVATE_STATE(NESTEDSTATES_SUP_A);
					/* --- Run exit() of and deactivate exited superstates, if any --- */
					/* --- Deactivate superstates and reset  to  their default substates, if any --- */
					/* --- Update target's superstates , if any --- */
					nestedStates_rootActiveState = NESTEDSTATES_SUP_C;
					/* --- Run entry() entered superstates and target state --- */
					/* SUP_C has no target states */
					nestedStates_SF_SUP_C_entry();
					/* --- Mark recent entered states as active --- */
					ACTIVATE_STATE(NESTEDSTATES_SUP_C);
					/* --- Run sub-statemachines, if any for entering substates --- */
					(void)nestedStates_runSubSM_SUP_C(NESTEDSTATES_NO_EXIT_REQUESTED);
				}
				else if(nestedStates_TTF_SUP_A_to_SUB_E())
				{
					/* TODO */
				}
				else if(nestedStates_TTF_SUP_A_to_SUP_E())
				{
					/* TODO */
				}
				else
				{
					/* Run during() of active state, if any */
					/* Run sub-statemachines, if any for during() execution */
					(void)nestedStates_runSubSM_SUP_A(NESTEDSTATES_NO_EXIT_REQUESTED);
				}
			}
			break;

		case NESTEDSTATES_RESERVED_INACTIVE_STATE:
			break;
	}
	return PYSM_E_OK;
}


pySm_returnType nestedStates_runSubSM_SUP_A(nestedStates_exitRequestType exitRq)
{
	switch(nestedStates_subSM_SUP_A)
	{
		case NESTEDSTATES_SUP_B:
			/* --- Handle entry --- */
			if(NESTEDSTATES_STATE_ACTIVE != nestedStates_stateStati[NESTEDSTATES_SUP_B])
			{
				ACTIVATE_STATE(NESTEDSTATES_SUP_B);
				nestedStates_SF_SUP_B_entry();
				/* Run sub-statemachines, if any for entering substates */
				(void)nestedStates_runSubSM_SUP_B(NESTEDSTATES_NO_EXIT_REQUESTED);
			}
			/* --- Handle exit --- */
			else if(NESTEDSTATES_EXIT_REQUESTED == exitRq)
			{
				/* Run exit() of substates, if any */
				(void)nestedStates_runSubSM_SUP_B(NESTEDSTATES_EXIT_REQUESTED);
				/* Run exit() of SUP_B , if any */
				/* Reset SUP_A state machine to default state */
				nestedStates_subSM_SUP_A = NESTEDSTATES_SUP_B;
				DEACTIVATE_STATE(NESTEDSTATES_SUP_B);
			}
			/* --- Handle exiting transitions and during() executions --- */
			else
			{
				if(nestedStates_TTF_SUP_B_to_SUB_D())
				{
					/* --- Execute TAF, if any --- */
					/* Transition SUP_B_to_SUB_D has no TAF */
					/* --- Run exit() of substates, if any --- */
					(void)nestedStates_runSubSM_SUP_B(NESTEDSTATES_EXIT_REQUESTED);
					/* --- Run exit() of active state on current level , if any --- */
					/* SUP_B has no exit() */
					/* --- Reset current superstate to default state --- */
					nestedStates_subSM_SUP_A = NESTEDSTATES_SUP_B;
					DEACTIVATE_STATE(NESTEDSTATES_SUP_B);
					/* --- Run exit() of and deactivate exited superstates, if any --- */
					/* --- Deactivate superstates and reset  to  their default substates, if any --- */
					DEACTIVATE_STATE(NESTEDSTATES_SUP_A);
					/* --- Update target's superstates , if any --- */
					nestedStates_subSM_SUP_D = NESTEDSTATES_SUB_D;
					nestedStates_subSM_SUP_C = NESTEDSTATES_SUP_D;
					nestedStates_rootActiveState = NESTEDSTATES_SUP_C;
					/* --- Run entry() entered superstates and target state --- */
					nestedStates_SF_SUP_D_entry();
					nestedStates_SF_SUP_C_entry();
					/* SUB_D has no entry () */
					/* --- Mark recent entered states as active --- */
					ACTIVATE_STATE(NESTEDSTATES_SUB_D);
					ACTIVATE_STATE(NESTEDSTATES_SUP_D);
					ACTIVATE_STATE(NESTEDSTATES_SUP_C);
					/* --- Run sub-statemachines, if any for entering substates --- */
					/* SUB_D has no sub-states */

				}
				else
				{
					/* Run during() of active state, if any */
					/* Run sub-statemachines, if any for during() execution */
					(void)nestedStates_runSubSM_SUP_B(NESTEDSTATES_NO_EXIT_REQUESTED);
				}
			}
			break;

		case NESTEDSTATES_SUB_C:
			/* --- Handle entry --- */
			if(NESTEDSTATES_STATE_ACTIVE != nestedStates_stateStati[NESTEDSTATES_SUB_C])
			{
				ACTIVATE_STATE(NESTEDSTATES_SUB_C);
				nestedStates_SF_SUB_C_entry();
			}
			/* --- Handle exit --- */
			else if(NESTEDSTATES_EXIT_REQUESTED == exitRq)
			{
				/* Run exit() of substates, if any */
				/* Run exit() of SUB_C , if any */
				/* Reset SUP_A state machine to default state */
				nestedStates_subSM_SUP_A = NESTEDSTATES_SUP_B;
				DEACTIVATE_STATE(NESTEDSTATES_SUB_C);
			}
			/* --- Handle exiting transitions and during() executions --- */
			else
			{
				if(nestedStates_TTF_SUB_C_to_SUB_F())
				{
					/* Execute TAF, if any */
					/* TODO */
				}
				else
				{
					/* Run during() of active state, if any */
					nestedStates_SF_SUB_C();
					/* Run sub-statemachines, if any for during() execution */
				}
			}
			/* Run sub-statemachines, if any */
			(void)nestedStates_runSubSM_SUP_B(NESTEDSTATES_NO_EXIT_REQUESTED);
			break;

		case NESTEDSTATES_RESERVED_INACTIVE_STATE:
			break;
	}
}

